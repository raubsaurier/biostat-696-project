library(Slurm)
#Get taskid from slurm
taskid <- slurm.array_task_id()
##----------------------------
### set up variables   ###
##----------------------------
J = 6                         # number of causes
N.SITE = 7                 # 3/20 -> change from 7 sites to 2 sites
cause_list = c(LETTERS[1:J])  # cause list - each letter stands for one cause
K = 1                         # number of subclasses
lambda = c(1,0)               # subclass weights for control group --> changed this so that
# it would take different TPR/FPR rates
eta = c(1,0)                  # subclass weights for case group --> same change to this
N = 300                       # number of subjects for control/case group
# etiology for all sites
# these are the  truth values for each site/pathogen
etiology_allsites = list(c(0.5,0.2,0.15,0.05,0.05,0.05),
c(0.2,0.5,0.15,0.05,0.05,0.05),
c(0.2,0.15,0.5,0.05,0.05,0.05),
c(0.2,0.15,0.05,0.5,0.05,0.05),
c(0.2,0.15,0.05,0.05,0.5,0.05),
c(0.2,0.15,0.05,0.05,0.05,0.5),
c(0.05,0.2,0.15,0.5,0.05,0.05))
# etiology only focusing on 2 sites
# etiology_allsites = list(c(0.5,0.2,0.15,0.05,0.05,0.05),
#                        c(0.05,0.2,0.15,0.5,0.05,0.05)) # site 2 and site 7
# FPR for MBS1 for all sites (7 site scenario)
PsiBS_MBS1_allsites = list(c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45),
c(0.45, 0.45, 0.45,0.45,0.45, 0.45))
####  2 sites  scenario #####
# PsiBS_MBS1_allsites = list(c(0.5,0.5,0.15,0.2,0.2,0.2),
#                            c(0.1,0.1,0.15,0.2,0.2,0.2))
# this is a function that creates a list of the parameters for the model
set.seed(201910222) # change seed to 2/22/19
data_nplcm_list = lapply(1:N.SITE,function(siteID){
set_parameter <- list( # list of the parameters that can be specified
cause_list      = cause_list,
etiology        = etiology_allsites[[siteID]],
pathogen_BrS    = LETTERS[1:J],
SS = T, #we have SS information as well as BrS
pathogen_SS     = LETTERS[1:3], # 4/18 -> change to 3
meas_nm         = list(MBS = c("MBS1"),MSS=c("MSS1")),
Lambda          = lambda,               # contral subclass weight for BrS
Eta             = t(replicate(J,eta)),  # case subclass weight for BrS
PsiBS           = cbind(PsiBS_MBS1_allsites[[siteID]],PsiBS_MBS1_allsites[[siteID]]), # FPR
PsiSS           = cbind(rep(0,J),rep(0,J)),
ThetaBS         = cbind(c(0.55,0.55,0.55,0.55,0.55,0.55),     # TPR for MBS1
c(0.95,0.95,0.95,0.95,0.95,0.95)),
ThetaSS         = cbind(c(0.2,0.2,0.2,0.2,0.2,0.2), # TPS for MSS1 -> #4/18 - change to 0.2
c(0.05,0.05,0.05,0.05,0.05,0.05)),
Nu      =     N,
Nd      =     N
)
simu_out   <- simulate_nplcm(set_parameter) # pass the true model parameters into a simulation function
data_nplcm <- simu_out$data_nplcm #simulation data using the above parameters
data_nplcm$X = data.frame(SITE=rep(siteID,(set_parameter$Nu+set_parameter$Nu)))      # set X as a data frame containing SITE
return(data_nplcm)
})
# put cases on top of controls
data_nplcm_order = unlist(lapply(1:N.SITE,function(i) ((i-1)*2*N+1):((i-1)*2*N+N)))
data_nplcm_order = c(data_nplcm_order, setdiff(1:(N*2*N.SITE),data_nplcm_order))
data_nplcm = list(Mobs=list(MBS = list(MBS1 = Reduce(rbind, lapply(data_nplcm_list, function(l) l$Mobs$MBS$MBS1))[data_nplcm_order,]),
MSS = list(MSS1 = Reduce(rbind, lapply(data_nplcm_list, function(l) l$Mobs$MSS$MSS1))[data_nplcm_order,]),
MGS=NULL),
Y = Reduce(c, lapply(data_nplcm_list, function(l) l$Y))[data_nplcm_order],
X = data.frame(SITE=Reduce(rbind, lapply(data_nplcm_list, function(l) l$X))[data_nplcm_order,]))
##----------------------------
### model specification  ###
##----------------------------
BrS_object_1 <- make_meas_object(LETTERS[1:J],"MBS","1","BrS",cause_list) # bronze standard
SS_object_1 <- make_meas_object(LETTERS[1:2],"MSS","1","SS",cause_list) #silver standard
model_options <- list(likelihood = list(cause_list = cause_list,              # <---- fitted causes.
k_subclass = c(1),                    # <---- no. of subclasses.
Eti_formula = ~ -1 + as.factor(SITE) , # <---- etiology regression formula; only for cases.
FPR_formula = list(
MBS1 =  ~ -1 +as.factor(SITE))),     # change from as.factor(SITE) to site for only one site
use_measurements = c("BrS","SS"),                       # <---- which measurements to use to inform etiology
prior = list(
Eti_prior = t(sapply(1:N.SITE, function(i) overall_uniform(1, cause_list))), # <--- here we are specifying the distribution for the etiology priors
TPR_prior = list(
BrS  = list(info = "informative", ## try with beta(6,2)
input = "direct_beta_param", # change to beta(1,1) or beta(2,1)
val = list(MBS1 = list(alpha = list(rep(6,6)),
beta  = list(rep(2,6))))),
SS = list(info  = "informative",
input = "match_range",
val   = list(
MSS1 = list(up = list(rep(0.3,length(SS_object_1$patho))),
low = list(rep(0.1,length(SS_object_1$patho))))))
)  # <---- TPR prior.
)
)
assign_model(model_options,data_nplcm)
##----------------------------
### model fitting   ###
##----------------------------
# parent directory for testing code (LOCAL):
working_dir <- tempdir()
# date stamp for analysis:
Date <- gsub("-", "_", Sys.Date())
# include stratification information in file name:
dated_strat_name <- paste0(working_dir,Date,"_discrete_predictor")
# create folder
result_folder <- dated_strat_name
dir.create(result_folder)
# options for MCMC chains:
mcmc_options <- list(debugstatus = TRUE,
n.chains   = 1, # number of Markov chains
n.itermcmc = as.integer(10000), # how many total iterations
n.burnin   = as.integer(5000), # how many iterations to throw away
n.thin     = 10, #thin every 10th draw from the sequence
individual.pred = !TRUE, #what does this mean?
ppd             = !TRUE,
get.pEti        = !TRUE,
result.folder = result_folder,
bugsmodel.dir = result_folder,
jags.dir = "",
use_jags = TRUE)
##----------------------------
###  function for simulation replicates   ###
##----------------------------
run_many_simulations <- function(run_times, data_nplcm,model_options, mcmc_options,
etiology_allsites, N.SITE, Jcause){
# create an array with # of dimensions corresponding to # of runs that will store the coverage indicators
coverage_counts <- array(c(rep(0,N.SITE), rep(0,Jcause)),dim = c(N.SITE,Jcause,run_times))
# create an array with # of dimensions corresponding to # of runs that will store mean/SD
posteriorSampMeans <- array(c(rep(0,N.SITE), rep(0,Jcause)),dim = c(N.SITE, Jcause,run_times)) ## means of posterior samples
posteriorSampSDs <- array(c(rep(0,N.SITE), rep(0,Jcause)),dim = c(N.SITE, Jcause,run_times)) ## SD of posterior samples
resNPLCM <- list()
posteriorSamples <- list() ## save the values of the posterior samples
# fix this later: posteriorPlots <- list() ## save the histograms of the posterior samples
rjags::load.module("glm")
for(run in 1:run_times){
gs <- nplcm(data_nplcm,model_options,mcmc_options)
DIR_NPLCM <- result_folder
new_env   <- new.env()
source(file.path(DIR_NPLCM,"jagsdata.txt"),local=new_env)
bugs.dat <- as.list(new_env)
rm(new_env)
res_nplcm <- coda::read.coda(file.path(DIR_NPLCM,"CODAchain1.txt"),
file.path(DIR_NPLCM,"CODAindex.txt"),
quiet=TRUE)
n_samp_kept   <- nrow(res_nplcm)      # number of posterior sample after burn-in
Jcause        <- bugs.dat$Jcause      # number of causes
Nd            <- bugs.dat$Nd          # case size
Nu            <- bugs.dat$Nu          # control size
n_unique_Eti_level <- bugs.dat$n_unique_Eti_level  # number of stratums
get_res <- function(x)res_nplcm[,grep(x,colnames(res_nplcm))]
## save the posterior samples of the model
resNPLCM[[run]] <- res_nplcm
# check if the model did actually run correctly:
Eti_prob_scale <- array(get_res("pEti"),c(n_samp_kept,n_unique_Eti_level,Jcause))
if(length(Eti_prob_scale)==0){
stop("Your model didn't run successfully!")
}
print(paste0("Number of Iterations:", run))
#posteriorSamples[[run]] <- Eti_prob_scale
### uncomment if you want the histogram plots
# marginalized posterior etiology over all sites using user-defined weights
#user_weight <- rep(1/N.SITE,N.SITE) # c(0.3,0.2,0.1,0.1,0.1,0.1,0.1)
#Eti_overall_usr_weight <- apply(Eti_prob_scale,1,function(S) t(S)%*%matrix(user_weight,ncol=1))
#
#
# fix this later:
# plot posterior distribution for etiology probability
# par(mfcol=c(1,1))
# for (j in 1:Jcause){
#   for (site in 1:n_unique_Eti_level){
#     hist(Eti_prob_scale[,site,j],xlim=c(0,1),breaks="Scott",freq=FALSE,main="",xlab="")
#     abline(v = etiology_allsites[[site]][[j]], col="blue", lwd=3, lty=2)
#     mtext(text = paste0('SITE',levels(as.factor(data_nplcm$X$SITE))[site],": ",cause_list[j]),3,-1,cex=1,adj = 0.9)
#     if (j==1){
#       mtext(paste0(round(user_weight[site],4)),2,5,cex=1,col="blue",las=1)
#       if (site==5) {mtext("User-specified weight towards overall pie:", 2,12, cex=1)}
#     }
#   }
#   hist(Eti_overall_usr_weight[j,],xlim=c(0,1),breaks="Scott",freq=FALSE,main="",col="blue",
#        xlab="Etiology")
#   mtext(text = paste0("Overall: ",cause_list[j]),3,adj=0.9,cex=1,col="blue")
# }
# posteriorPlots[[run]] <- recordPlot()
## function that checks for each site and cause if the truth is covered by the 95% quantile of the posterior distribution
for(j in 1:Jcause){
for(site in 1:N.SITE){
posteriorSampMeans[site, j,run] <- round(mean(Eti_prob_scale[,site,j]), 4)
posteriorSampSDs[site, j, run] <- round(sd(Eti_prob_scale[,site,j]), 4)
truth_value <- etiology_allsites[[site]][[j]] # this is the true etiology value for the ith pathogen
if((truth_value>=quantile(Eti_prob_scale[, site,j], probs=c(0.02, 0.975))[1])&(truth_value<=quantile(Eti_prob_scale[,site,j], probs=c(0.02, 0.975))[2])){ # check if the true value is covered by the 95% quantile
coverage_counts[site,j,run] <- 1 # if it is, assign 1
} else {
coverage_counts[site,j,run] <- 0  #assign zero if true value is not covered
}
}
}
}
simulationResults <- list("coverage_counts" = coverage_counts, "posteriorSampMeans" = posteriorSampMeans,
"posteriorSampSDs" = posteriorSampSDs,"resNPLCM" = resNPLCM  #, "posteriorPlots" = posteriorPlots,#"posteriorSamples" = posteriorSamples
)
return(simulationResults)
}
##----------------------------
###  function for simulation replicates   ###
##----------------------------
ptm <- proc.time()
set.seed(03192019)
simulationResults<- run_many_simulations(run_times = 1, data_nplcm,model_options,  mcmc_options, etiology_allsites, N.SITE = 7, Jcause = 6)
proc.time() - ptm
rm(list=ls())
library(geoR)
library(data.table)
library(ggplot2)
library(dplyr)
library(rgdal)
library(RColorBrewer)
library(classInt)
library(tidyverse)
library(usmap)
library(maps)
library(maptools)
library(CARBayes)
library(spdep)
library(splancs)
library(spatstat)
library(spatialkernel)
setwd("~/Fall 2018/tmp")
cancer_data <- data.table(read.csv("~/Library/Mobile Documents/com~apple~CloudDocs/School/Year 1 Classes/Biostat 696/HW/HW4/Cancer_data.txt",  sep=""))
polygon_data <- data.table(read.csv("~/Library/Mobile Documents/com~apple~CloudDocs/School/Year 1 Classes/Biostat 696/HW/HW4/Polygon_cancer_data.txt",  sep=""))
larynxData <- cancer_data[cancer.type=="larynx"]
## Here we plot the points
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
View(cancer_data)
larynx.poly <- as.points(c(min(polygon_data$x),max(polygon_data$x),max(polygon_data$x),min(polygon_data$x)),
c(max(polygon_data$y),max(polygon_data$y),min(polygon_data$y),min(polygon_data$y)))
plot(larynx.poly , type="l")
View(larynx.poly)
?dist
View(larynx.poly)
366.45-345.45
431.79-410.41
kappa = nrow(larynxData)/(21*21.38)
library(plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(353,421,5,nv=,border=NULL,col=NA,lty=1,lwd=1)
)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(353,421,5,nv=,border=NULL,col=NA,lty=1,lwd=1)
install.packages("plotrix")
library(plotrix)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(353,421,5,nv=,border=NULL,col=NA,lty=1,lwd=1)
draw.circle(353,421,0.05,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(353,421,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352,421,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352,422,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(353,422,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352.5,422,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352.5,421.5,1,nv=,border=NULL,col=NA,lty=1,lwd=1)
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352.5,421.25,1.2,nv=,border=NULL,col=NA,lty=1,lwd=1)
# we find r = 1 gives us a circle that contains these points and centere
the circle there:
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352.5,421.5,1.2,nv=,border=NULL,col=NA,lty=1,lwd=1)
## polygon of the x/y coords of the larynx cancer cases
larynx.poly <- as.points(c(min(polygon_data$x),max(polygon_data$x),max(polygon_data$x),min(polygon_data$x)),
c(max(polygon_data$y),max(polygon_data$y),min(polygon_data$y),min(polygon_data$y)))
plot(larynx.poly , type="l")
larynx_point <- matrix(NA, nrow=length(larynxData$x),ncol=2)
larynx_point[,1] <- larynxData$x
larynx_point[,2] <- larynxData$y
## This function computes the MSE for the estimated intensity function using different bandwidths
mse.larynx <- mse2d(larynx_point, poly=larynx.poly, nsmse=10, range=.5)
################# L function
window <- owin(c(min(polygon_data$x),max(polygon_data$x)),c(min(polygon_data$y),max(polygon_data$y)))
larynxPP <- ppp(larynxData$x, larynxData$y,window=window)
## L function
L.larynx <- Lest(larynxPP)
plot(L.larynx, main="L function of Larynx Cancer Cases")
## K function:
K.larynx <- Kest(larynxPP)
plot(K.larynx, main="K function of Larynx Cancer Cases")
plot(larynxPP)
quadrat.test(larynxPP)
quadrat.test(larynxPP, alternative = "regular")
quadrat.test(larynxPP, alternative = "clustered")
## get the lung cancer data separately (for plotting)
lungCancer <- cancer_data[cancer.type=="lung"]
## calculate the optimal bandwidth using the bw.diggle function
bw.diggle <- bw.diggle(larynxPP)
bw.diggle
## using the BW diggle as the bandwith setting for our intensity function :
int.larynx <- density(larynxPP, bw.diggle)
plot(int.larynx, main="Kernel estimate of intensity function")
plot(lungCancer$x, lungCancer$y)
plot(lungCancer$x, lungCancer$y, main="Plot of Lung Cancer Cases")
## Here we plot the points
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
larynx.logcp <- lgcp.estK(larynxPP, c(sigma2=10, alpha=2))
larynx.logcp
?lgcp.estK
larynx.logcp$fit
larynx.logcp$opt
larynx.logcp$par
larynx.logcp$opt
?envelope
env = envelope(larynx.logcp$fit, fun = Gest, nsim = 999)
env.profile()
plot(larynx.logcp)
envcellsF <- envelope(larynxPP,fun=Fest,rank=1,nsim=99)
plot(envcellsF,main="F function \n Cell centers")
envcellsL <- envelope(larynxPP,fun=Fest,rank=1,nsim=99)
plot(envcellsF,main="L function \n Cell centers")
envcellsL <- envelope(larynxPP,fun=Kest,rank=1,nsim=99)
plot(envcellsF,main="K function \n Cell centers")
larynxK <- envelope(larynxPP,fun=Kest,rank=1,nsim=100)
plot(envcellsK,main="K function \n of the Larynx PP")
plot(larynxK,main="K function \n of the Larynx PP")
## K function:
K.larynx <- Kest(larynxPP)
plot(K.larynx, main="K function of Larynx Cancer Cases")
larynxL <- envelope(larynxPP,fun=Lest,rank=1,nsim=100)
plot(larynxL,main="K function \n of the Larynx PP")
larynxK <- envelope(larynxPP,fun=Kest,rank=1,nsim=100)
plot(larynxK,main="K function \n of the Larynx PP")
## K function:
K.larynx <- Kest(larynxPP)
plot(K.larynx, main="K function of Larynx Cancer Cases")
?L.larynx <- Lest(larynxPP)
plot(L.larynx, main="L function of Larynx Cancer Cases")
## K function:
K.larynx <- Kest(larynxPP)
plot(K.larynx, main="K function of Larynx Cancer Cases")
larynxK <- envelope(larynxPP,fun=Kest,rank=1,nsim=99)
plot(larynxK,main="K function \n of the Larynx PP")
int.larynx <- density(larynxPP, bw.diggle)
plot(int.larynx, main="Kernel estimate of intensity function")
plot(larynxData$x, larynxData$y,main="Larynx cancer cases", xlab="X",ylab="Y",pch=20)
draw.circle(352.5,421.5,1.2,nv=,border=NULL,col=NA,lty=1,lwd=1)
# we find r = 1.2 gives us a circle that contains these points and centers roughly the middle of the points
## to estimate the initial value of kappa, we can divide the number of points by the area of the region (enclosed by the window):
kappa = nrow(larynxData)/(21*21.38)
u.matclust <- matclust.estK(larynxPP, c(kappa=kappa, R=1.2))
u.matclust
plot(u.matclust)
?matclust.estK
larynx.logcp <- lgcp.estK(larynxPP, c(sigma2=10, alpha=2))
plot(larynx.logcp)
plot(larynx.logcp, main="log-Gaussian Cox Process K function")
plot(larynx.matclust)
kappa = nrow(larynxData)/(21*21.38)
larynx.matclust <- matclust.estK(larynxPP, c(kappa=kappa, R=1.2))
plot(larynx.matclust, "Matern cluster process")
kappa = nrow(larynxData)/(21*21.38)
larynx.matclust <- matclust.estK(larynxPP, c(kappa=kappa, R=1.2))
plot(larynx.matclust, main="Matern cluster process")
plot(larynx.logcp, main="log-Gaussian Cox Process K function")
setwd("~/repos/biostat-696-project")
rm(list=ls())
library(data.table)
library(readxl)
library(dplyr)
educ2016 <- data.table(read_xlsx("high_school_completion_2016.xlsx"))
View(educ2016)
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
View(educ2016)
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
View(educ2016)
?fips
educ2016$fips <- fips(educ2016[,1])
View(educ2016)
educ2016$fips <- fips(educ2016$Table.1.)
View(educ2016)
educ2016 <- educ2016[!is.na(fips)]
View(educ2016)
setnames(educ2016, c("state", "pct_high_school", "fips"))
View(educ2016)
asthma_total <- data.table(read.csv(2016Asthma_Final_w_KrigingParams_PM25.csv"))
asthma_total <- data.table(read.csv("2016Asthma_Final_w_KrigingParams_PM25.csv"))
View(asthma_total)
asthma <- merge(asthma_total, educ2016, by=c("state", "fips"))
educ2016$fips <- as.numeric(educ2016$fips)
asthma <- merge(asthma_total, educ2016, by=c("state", "fips"))
View(asthma)
plot_usmap(data =educ2016, values = "pct_high_school", lines = "black") +
scale_fill_gradientn(colours=blue2red(5), name="% HS Graduation") +
theme(legend.position = "right") +
labs(title=paste0("2016 4 Year High School Graduation Rate"))
educ2016$pct_high_school <- as.numeric(educ2016$pct_high_school)
View(educ2016)
## load in 2016 air quality data
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
educ2016$fips <- fips(educ2016$Table.1.)
educ2016 <- educ2016[!is.na(fips)]
setnames(educ2016, c("state", "pct_high_school", "fips"))
educ2016$fips <- as.numeric(educ2016$fips)
educ2016$pct_high_school <- as.character(educ2016$pct_high_school)
educ2016$pct_high_school <- as.numeric(educ2016$pct_high_school)
plot_usmap(data =educ2016, values = "pct_high_school", lines = "black") +
scale_fill_gradientn(colours=blue2red(5), name="% HS Graduation") +
theme(legend.position = "right") +
labs(title=paste0("2016 4 Year High School Graduation Rate"))
plot_usmap(data =educ2016, values = "pct_high_school", lines = "black", labels = TRUE) +
scale_fill_gradientn(colours=blue2red(5), name="% HS Graduation") +
theme(legend.position = "right") +
labs(title=paste0("2016 4 Year High School Graduation Rate"))
View(educ2016)
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
educ2016$fips <- fips(educ2016$Table.1.)
View(educ2016)
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
educ2016[Table.1=="Virgini3"]$Table.1. <- "Virginia"
educ2016$fips <- fips(educ2016$Table.1.)
educ2016 <- educ2016[!is.na(fips)]
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
educ2016[Table.1.=="Virgini3"]$Table.1. <- "Virginia"
educ2016$fips <- fips(educ2016$Table.1.)
View(educ2016)
educ2016 <- data.table(read.csv("ACGR_RE_Characteristics_2016.csv"))
# jsut get the state and the % high school complettion rates
educ2016 <- educ2016[,c(1:2)]
educ2016[Table.1.=="Virginia3"]$Table.1. <- "Virginia"
educ2016$fips <- fips(educ2016$Table.1.)
educ2016 <- educ2016[!is.na(fips)]
View(educ2016)
setnames(educ2016, c("state", "pct_high_school", "fips"))
educ2016$fips <- as.numeric(educ2016$fips)
educ2016$pct_high_school <- as.character(educ2016$pct_high_school)
educ2016$pct_high_school <- as.numeric(educ2016$pct_high_school)
plot_usmap(data =educ2016, values = "pct_high_school", lines = "black", labels = TRUE) +
scale_fill_gradientn(colours=blue2red(5), name="% HS Graduation") +
theme(legend.position = "right") +
labs(title=paste0("2016 4 Year High School Graduation Rate"))
asthma <- merge(asthma_total, educ2016, by=c("state", "fips"))
View(asthma)
asthma$pct_daily_smokers <- asthma$pct_daily_smokers*100
write.csv(asthma, "2016Asthma_Final_w_KrigingParams_PM25.csv", row.names = FALSE)
View(asthma)
asthma[which(asthma$state == "New Hampshire"), "asthma_count"] = 28477
asthma[which(asthma$state == "Iowa"), "asthma_count"] = 62517
## NOTE: MUST CHANGE POPULATION COUNTS TO REFLECT CHANGE IN YEAR
states_subset = c("Maine", "New Hampshire", "Vermont", "New York",
"Massachusetts", "Connecticut", "Rhode Island",
"New Jersey", "Pennsylvania", "Ohio", "Wisconsin",
"Indiana", "Kentucky", "Michigan", "Illinois",
"Missouri", "Iowa", "Minnesota", "Nebraska",
"Kansas", "Oklahoma")
asthma_sub = asthma %>%
filter(state %in% states_subset)
plot_usmap(data = asthma_sub[,1:3], values = "asthma_count", lines = "black", labels = TRUE) +
scale_fill_gradientn(colours=blue2red(8), name="Asthma Count") +
theme(legend.position = "right") +
labs(title="2016 Asthma Counts")
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers + pct_high_school,
family = poisson,
data = asthma_sub)
summary(health_model)
# all variables significant
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers + pct_high_school,
family = poisson,
data = asthma_sub)
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers + pct_high_school,family = poisson,data = asthma_sub)
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers,
family = poisson,
data = asthma_sub)
summary(health_model)
# all variables significant
library(data.table)
library(readxl)
library(RColorBrewer)
library(classInt)
library(geoR)
library(spBayes)
library(fields)
library(MBA)
library(akima)
library(ggplot2)
library(usmap)
library(colorRamps)
library(gstat)
library(CARBayes)
library(maptools)
library(spdep)
library(dplyr)
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers,
family = poisson,
data = asthma_sub)
summary(health_model)
# all variables significant
health_model = glm(asthma_count ~ offset(log(total_population)) + obesity_rate_2016 + pct_daily_smokers,
family = poisson,
data = asthma_sub)
View(asthma_sub)
?glm
